#!/usr/bin/env node 

/*
  (c) 2013-2014 musictheory.net, LLC
  MIT license, http://www.opensource.org/licenses/mit-license.php
*/

var fs       = require("fs");
var util     = require("util");
var esprima  = require("esprima-oj");
var getopt   = require("node-getopt");
var ojc      = require("../src/ojc");


var opt = getopt.create([
    [ "o", "output=FILE",               "output .js file"],
    [ "",  "input-state=FILE",          "input file for compiler state" ],
    [ "",  "output-state=FILE",         "output file for compiler state" ],
    [ "",  "prepend=FILE+",             "prepend file to output (without compiling)"],
    [ "",  "append=FILE+",              "append file to output (without compiling)"],
    [ "s", "squeeze",                   "enable oj squeezer" ],

    [ "",  "check-ivars",               "warn about potentially undefined ivars"   ],
    [ "",  "check-this",                "warn about usage of 'this' in oj methods" ],
    [ "",  "without-class=NAME+",       "strip specified class"                    ],

    [ "",  "debug-message-send",        "use debug version of oj.msgSend" ],
    [ "",  "dump-ast",                  "(for development)" ],
    [ "",  "dump-modifier",             "(for development)" ],
    [ "",  "dump-time",                 "(for development)" ],

    [ "h", "help",                      "display this help" ],
    [ "v", "version",                   "show version"      ]
]);


opt.setHelp(
    "Usage: ojc [OPTIONS] INPUT_FILES\n" +
    "\n" +
    "[[OPTIONS]]\n" +
    "\n" +
    "Installation: npm install ojc\n" +
    "Respository:  https://github.com/musictheory/oj"
);

opt.bindHelp();
opt.parseSystem();

var inputFiles = opt.parsedOption.argv;
var options    = opt.parsedOption.options;


// Bail if no input files
if (!inputFiles || inputFiles.length == 0) {
    console.error("ojc: error: no input files");
    process.exit(1);
}


// Read each input file and store in inContent
var inputContents = [ ];
inputFiles.forEach(function(f) {
    try {
        inputContents.push(fs.readFileSync(f).toString());
    } catch (e) {
        console.error("ojc: error: " + e);
        process.exit(1);
    }
});

// Read each prepend file and store in inputPrependContents
var prependFiles = opt.parsedOption.prepend || [ ];
var prependContents = [ ];
prependFiles.forEach(function(f) {
    try {
        prependContents.push(fs.readFileSync(f).toString());
    } catch (e) {
        console.error("ojc: error: " + e);
        process.exit(1);
    }
});

// Read each append file and store in appendContents
var appendFiles = opt.parsedOption.append || [ ];
var appendContents = [ ];
appendFiles.forEach(function(f) {
    try {
        appendContents.push(fs.readFileSync(f).toString());
    } catch (e) {
        console.error("ojc: error: " + e);
        process.exit(1);
    }
});


options["files"]    = inputFiles;
options["contents"] = inputContents;

if (prependContents.length) {
    options["prepend"]  = prependContents.join("\n");
}

if (appendContents.length) {
    options["append"] = appendContents.join("\n");
}

var inputStateFile  = options["input-state"];
var outputStateFile = options["output-state"];
var outputFile      = options["output"];

delete(options["input-state"]);
delete(options["output-state"]);
delete(options["output"]);


// Read inputStateFile and save contents into options.state
if (inputStateFile) {
    try {
        options["state"] = JSON.parse(fs.readFileSync(inputStateFile));
    } catch (e) {
        console.error("ojc: error: " + e);
        process.exit(1);
    }
}

var result;

try {
    result = ojc.ojc(options);

} catch (e) {
    if (inputFiles.length == 1) {
        console.log(inputFiles[0] + ":" + e.lineNumber + " " + e.description);
    } else {
        console.log(e.description);
    }

    if (!e.errorType) console.log(e.stack);
    process.exit(2);
}

var outContent  = result.content;
var outputState = result.state;

if (outputFile) {
    fs.writeFileSync(outputFile, outContent, "utf8")
} else {
    if (outContent) {
        process.stdout.write(outContent);
    }
}

if (outputStateFile) {
    fs.writeFileSync(outputStateFile, JSON.stringify(outputState || { }, null, "    "), "utf8")
}


// process.exit(0);

